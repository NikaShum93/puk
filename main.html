<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Sheep Run</title>

  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

  <style>
    :root { --move-speed: 3.5s; --hero-scale: 1; --q-font: 8vmin; }

    * { box-sizing: border-box; }
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#333; }
    body.transparent, html.transparent { background:transparent !important; }

    #game-app{
      width:100%; height:100%;
      font-family:'Fredoka One', cursive;
      display:flex; flex-direction:column;
      background:#4FC3F7;
      user-select:none; -webkit-user-select:none;
    }
    #game-app.transparent{ background:transparent !important; }

    #sky-area{
      position:relative; flex:1; width:100%; overflow:hidden;
      background: linear-gradient(#6fd5ff 0%, #b8ecff 55%, #eaf9ff 100%);
    }
    .cloud{
      position:absolute; top:10%; left:110%;
      width:22vmin; height:12vmin;
      background:rgba(255,255,255,.85);
      border-radius:999px;
      filter: blur(.2px);
      box-shadow: -6vmin 2vmin 0 0 rgba(255,255,255,.85),
                  -11vmin 1vmin 0 0 rgba(255,255,255,.75),
                  6vmin 2vmin 0 0 rgba(255,255,255,.75),
                  10vmin 1vmin 0 0 rgba(255,255,255,.7);
      animation: cloudMove 22s linear infinite;
      opacity:.9;
      pointer-events:none;
    }
    @keyframes cloudMove{ from{ transform:translateX(0);} to{ transform:translateX(-140vw);} }
    #question-text img{ max-width:100%; max-height:28vh; display:block; margin:0 auto; }
    .action-btn img{ max-height:60%; max-width:90%; object-fit:contain; }
    #ground-area{
      position:relative; flex:none; width:100%; height:auto;
      padding:10px 0;
      background:#66BB6A; border-top:8px solid #43A047;
      background-image: radial-gradient(#81C784 15%, transparent 16%);
      background-size:60px 60px;
      display:flex; align-items:center; justify-content:center; z-index:20;
      animation: moveGrass var(--move-speed) linear infinite;
    }
    @keyframes moveGrass{ from{background-position-x:0} to{background-position-x:-150vw} }

    /* HUD */
    .hud-container{
      position:absolute; top:15px; left:0; width:100%;
      padding:0 5vmin; display:flex; justify-content:space-between;
      align-items:center; z-index:100; pointer-events:none;
    }
    .lives-box{ font-size:7vmin; filter:drop-shadow(0 3px 0 rgba(0,0,0,0.1)); }
    .hud-right{ display:flex; align-items:center; gap:4vmin; }
    .score-row{ display:flex; align-items:center; gap:15px; }
    .combo-badge{
      background:#FF9800; color:white;
      padding:5px 15px; border-radius:10px;
      font-size:3.5vmin; transform:rotate(-5deg);
      box-shadow:0 4px 0 #E65100; border:2px solid white; white-space:nowrap;
    }
    .score-val{ color:white; font-size:5.5vmin; text-shadow:2px 2px 0 rgba(0,0,0,0.1); }
    .progress-bar{ width:25vmin; height:20px; background:rgba(0,0,0,0.3); border:3px solid #fff; border-radius:15px; overflow:hidden; }
    .progress-fill{ width:0%; height:100%; background:#FFEB3B; transition:width 0.35s; }

    /* QUESTION CARD */
    .q-card{
      position:absolute; top:18%; left:50%; transform:translateX(-50%);
      background:#fff; padding:25px 50px; border-radius:30px; border:6px solid #ECEFF1;
      min-width:70%; max-width:90%; z-index:50; text-align:center;
      box-shadow:0 8px 0 rgba(0,0,0,0.05);
    }
    #question-text{ font-size:var(--q-font, 8vmin); color:#333; margin:0; line-height:1.1; }

    /* HERO */
    .hero-char{
      position:absolute; bottom:0; left:15%;
      width:15vh; height:15vh;
      z-index:25; display:flex; align-items:center; justify-content:center;
      font-size:13vh;
      transform: scaleX(var(--hero-scale));
    }
    .bobbing{ animation: runBob 0.4s infinite alternate; }
    @keyframes runBob { from{transform:translateY(0) scaleX(var(--hero-scale));} to{transform:translateY(-1.5vh) scaleX(var(--hero-scale));} }
    .jump-anim{ animation: jumpArc 1.0s cubic-bezier(0.4,0,0.2,1) forwards; }
    @keyframes jumpArc { 0%,100%{ bottom:0; transform:scaleX(var(--hero-scale)); } 50%{ bottom:32%; transform:scaleX(var(--hero-scale)); } }
    .blink-anim{ animation: blink-effect 0.2s infinite; filter:sepia(1) saturate(10) hue-rotate(-50deg); }
    @keyframes blink-effect{ 50%{ opacity:0.4; } }

    /* OBJECTS */
    .game-obj{
      position:absolute; left:110%; z-index:20;
      font-size:14vh; width:14vh; height:14vh;
      display:flex; align-items:center; justify-content:center;
      transition:opacity 0.2s;
    }
    .obj-move{ animation: slideLeft var(--move-speed) linear forwards; }
    @keyframes slideLeft{ from{left:110%} to{left:-40%} }
    .pos-ground{ bottom:0; }
    .pos-air{ bottom:22%; }
    .obj-caught{ animation: catch-pop 0.4s ease-out forwards; pointer-events:none; }
    @keyframes catch-pop{ 0%{transform:scale(1);opacity:1;} 100%{transform:scale(1.8);opacity:0;} }

    /* Floating score */
    .floating-text{
      position:absolute; font-size:6vmin; font-weight:bold; z-index:150;
      pointer-events:none; animation: float-up 0.8s ease-out forwards;
      text-shadow:2px 2px 0 rgba(0,0,0,0.2);
    }
    @keyframes float-up{ 0%{transform:translateY(0);opacity:1;} 100%{transform:translateY(-100px);opacity:0;} }

    
        /* OVERLAYS */
    .overlay{
      position:absolute; inset:0; z-index:200;
      background:#4FC3F7;
      display:flex; flex-direction:column;
      align-items:center; justify-content:center;
      color:white; padding:20px; text-align:center;
    }
    .start-title{ font-size:12vh; margin:0; text-shadow:0 8px 0 rgba(0,0,0,0.1); }

    .start-emojis{
      position:relative;
      width:min(520px, 90vw);
      height:25vh;
      display:flex;
      align-items:center;
      justify-content:center;
      margin-bottom:20px;
    }
    .start-hero{
      position:relative;
      width:22vh;
      height:22vh;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:20vh;
      z-index:2;
      transform: scaleX(var(--hero-scale));
    }
    /* –ü—É–∫ –≤—Å–µ–≥–¥–∞ —Å–ª–µ–≤–∞ –æ—Ç –≥–µ—Ä–æ—è –∏ —É–ª–µ—Ç–∞–µ—Ç –≤–ª–µ–≤–æ */
    .start-smoke{
      position:absolute;
      left:50%;
      top:50%;
      transform: translate(-175%, -35%) scaleX(-1);
      font-size:12vh;
      z-index:1;
      animation:fartPuff 1.2s ease-out infinite;
      pointer-events:none;
      opacity:0;
    }
    @keyframes fartPuff{
      0%{ transform: translate(-120%, -35%) scaleX(-1) scale(0.35); opacity:0; }
      15%{ opacity:1; }
      100%{ transform: translate(-220%, -35%) scaleX(-1) scale(1.35); opacity:0; }
    }

    .settings-box{
      background:rgba(255,255,255,0.2);
      border:2px solid white;
      border-radius:20px;
      padding:12px;
      width:280px;
      display:flex; flex-direction:column; gap:10px;
      margin-bottom:20px;
    }
    .set-row{ display:flex; align-items:center; gap:12px; }
    .icon-btn{ cursor:pointer; font-size:24px; }
    input[type=range]{ -webkit-appearance:none; width:100%; background:white; height:6px; border-radius:5px; cursor:pointer; }

    .diff-row{ display:flex; justify-content:center; gap:15px; margin-bottom:30px; }
    .diff-btn{
      font-size:35px; width:70px; height:70px;
      background:rgba(255,255,255,0.3);
      border:3px solid transparent;
      border-radius:15px;
      cursor:pointer;
      display:flex; align-items:center; justify-content:center;
      transition:0.2s;
    }
    .diff-btn.active{ background:white; border-color:#FFEB3B; transform:scale(1.1); box-shadow:0 5px 15px rgba(0,0,0,0.1); }

    #prep-screen{ display:none; background:rgba(79,195,247,0.98); }
    .countdown-text{ font-size:18vh; margin:10px 0; color:#FFEB3B; text-shadow:0 8px 0 #E65100; }
    .tutorial-box{
      background:white; color:#333;
      border-radius:35px;
      padding:25px;
      width:95%; max-width:650px;
      box-shadow:0 10px 0 rgba(0,0,0,0.1);
      border:8px solid #ECEFF1;
    }
    .tut-grid{ display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-top:15px; }
    .tut-icon-wrap{ width:65px; height:65px; background:#F5F5F5; border-radius:12px; display:flex; align-items:center; justify-content:center; font-size:40px; margin:3px; }

    .action-btn{
      background:#FFEB3B; color:#E65100;
      font-size: var(--btnSize);
      padding:20px 80px;
      border-radius:60px;
      border:none;
      border-bottom:10px solid #F57F17;
      cursor:pointer;
      font-family:'Fredoka One', cursive;
    }
    .action-btn:active{ transform:translateY(4px); border-bottom-width:6px; }

    /* input mode panel */
    .input-panel{ display:flex; gap:12px; align-items:center; justify-content:center; width:min(900px, 95vw); padding:0 10px; }
    .answer-input{
      flex:1;
      padding:14px 16px;
      border:none;
      border-radius:18px;
      font-family:'Fredoka One', cursive;
      font-size:5vmin;
      outline:none;
      box-shadow:0 10px 0 rgba(0,0,0,0.12);
    }
    .ok-btn{
      padding:14px 22px;
      border-radius:999px;
      border:none;
      cursor:pointer;
      font-family:'Fredoka One', cursive;
      font-size:5vmin;
      background:#fff;
      color:#E65100;
      box-shadow:0 10px 0 rgba(0,0,0,0.12);
    }
    .ok-btn:active{ transform:translateY(3px); }
  </style>
</head>
<body>

<div id="game-app">
  <div id="start-screen" class="overlay">
    <h1 class="start-title" id="uiTitle">SHEEP RUN</h1>
    <div id="cfgNote" style="margin-top:8px;font-size:16px;opacity:.85;max-width:85vw;"></div>
    <div class="start-emojis">
      <div class="start-smoke" id="startSmoke">üí®</div>
      <div class="start-hero" id="startHero">üêë</div>
    </div>

    <div class="settings-box">
      <div class="set-row">
        <span class="icon-btn" id="musIcon">üéµ</span>
        <input type="range" id="slider-mus" min="0" max="1" step="0.1" value="0.5">
      </div>
      <div class="set-row">
        <span class="icon-btn" id="sfxIcon">üîä</span>
        <input type="range" id="slider-sfx" min="0" max="1" step="0.1" value="1">
      </div>
    </div>

    <div class="diff-row">
      <div class="diff-btn" id="diff-easy">üçº</div>
      <div class="diff-btn active" id="diff-medium">üêë</div>
      <div class="diff-btn" id="diff-hard">‚ö°</div>
    </div>

    <button class="action-btn" id="btnStart">START</button>
  </div>

  <div id="prep-screen" class="overlay">
    <div class="tutorial-box">
      <h2 id="prepTitle" style="margin-top:0; color:#4FC3F7; font-size:6vmin;">READY?</h2>
      <div class="tut-grid">
        <div>
          <div id="prepCollect" style="color:#66BB6A; margin-bottom:10px; font-size:4vmin;">COLLECT</div>
          <div id="tut-good-list" style="display:flex; flex-wrap:wrap; justify-content:center;"></div>
        </div>
        <div>
          <div id="prepAvoid" style="color:#FF5252; margin-bottom:10px; font-size:4vmin;">AVOID</div>
          <div id="tut-bad-list" style="display:flex; flex-wrap:wrap; justify-content:center;"></div>
        </div>
      </div>
    </div>
    <div id="countdown" class="countdown-text">5</div>
    <div id="prepHint" style="font-size:30px;">GET READY!</div>
  </div>

  <div id="sky-area">
      <div class="cloud" style="top:10%; animation-duration:26s; opacity:.85;"></div>
      <div class="cloud" style="top:28%; animation-duration:32s; animation-delay:-10s; opacity:.7; transform:scale(.8);"></div>
      <div class="cloud" style="top:18%; animation-duration:38s; animation-delay:-20s; opacity:.6; transform:scale(1.1);"></div>

    <div class="hud-container">
      <div id="lives-display" class="lives-box">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
      <div class="hud-right">
        <div class="score-row">
          <div id="combo-display" class="combo-badge">x1.0</div>
          <div class="score-val" id="score-display">0</div>
        </div>
        <div class="progress-bar"><div id="progress-fill" class="progress-fill"></div></div>
      </div>
    </div>

    <div id="question-card" class="q-card" style="display:none;">
      <p id="question-text">...</p>
    </div>

    <div id="hero" class="hero-char">üêë</div>
    <div id="objects-layer"></div>
  </div>

  <div id="ground-area">
    <!-- choice mode (2) -->
    <div id="choicePanel" style="display:flex; gap:30px;">
      <button id="btn-left" class="action-btn">A</button>
      <button id="btn-right" class="action-btn">B</button>
    </div>
<!-- input mode -->
    <div id="inputPanel" class="input-panel" style="display:none;">
      <input id="answerInput" class="answer-input" placeholder="Type answer...">
      <button id="btnOk" class="ok-btn">OK</button>
    </div>
  </div>

  <div id="end-screen" class="overlay" style="display:none;">
    <h1 id="end-emoji" style="font-size:100px;">üèÜ</h1>
    <h2 id="end-title" style="font-size:40px; margin:10px 0;">YOU WIN!</h2>
    <p id="end-score-text" style="font-size:24px; margin-bottom:20px;">Score: 0</p>
    <button class="action-btn" id="btnAgain">AGAIN</button>
  </div>
</div>

<audio id="mus-bg" loop></audio>
<audio id="sfx-ding"></audio>
<audio id="sfx-buzz"></audio>
<audio id="sfx-coin"></audio>
<audio id="sfx-crash"></audio>
<audio id="sfx-win"></audio>

<script>
  const urlParams = new URLSearchParams(location.search);
  const cfgId = urlParams.get('id');
  const localMode = urlParams.get('local') === '1';
  const previewMode = urlParams.get('preview') === '1';

  // –í–ê–ñ–ù–û: JSON –ª–µ–∂–∏—Ç –≤ nikashum93/texts/data/<id>.json
  const JSON_BASE = "https://nikashum93.github.io/texts/data/";

  function shuffle(arr){
    const a = arr.slice();
    for(let i=a.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  }

  function looksLikeUrl(s){
    return typeof s === 'string' && (s.startsWith('http://') || s.startsWith('https://') || s.startsWith('data:'));
  }
  function looksLikeImgUrl(s){
    return looksLikeUrl(s) && (/(\.png|\.jpg|\.jpeg|\.gif|\.webp)(\?.*)?$/i.test(s) || s.startsWith('data:image/'));
  }
  function renderContent(el, data){
    el.innerHTML = '';
    if(looksLikeImgUrl(data)){
      const img = document.createElement('img');
      img.src = data;
      img.style.width='100%';
      img.style.height='100%';
      img.style.objectFit='contain';
      el.appendChild(img);
    }else{
      el.textContent = data ?? '';
    }
  }

  // -------- CONFIG DEFAULTS --------
  const UI_DEFAULTS = {
    ru:{title:"SHEEP RUN", start:"–ò–ì–†–ê–¢–¨", again:"–ï–©–Å –†–ê–ó", gameover:"–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê", scoreLabel:"–°—á—ë—Ç: "},
    en:{title:"SHEEP RUN", start:"PLAY", again:"AGAIN", gameover:"GAME OVER", scoreLabel:"Score: "},
    fr:{title:"SHEEP RUN", start:"JOUER", again:"REJOUER", gameover:"FIN DE PARTIE", scoreLabel:"Score : "},
    de:{title:"SHEEP RUN", start:"SPIELEN", again:"NOCHMAL", gameover:"GAME OVER", scoreLabel:"Punkte: "},
    es:{title:"SHEEP RUN", start:"JUGAR", again:"OTRA VEZ", gameover:"GAME OVER", scoreLabel:"Puntuaci√≥n: "},
    it:{title:"SHEEP RUN", start:"GIOCA", again:"DI NUOVO", gameover:"GAME OVER", scoreLabel:"Punteggio: "},
    zh:{title:"SHEEP RUN", start:"ÂºÄÂßã", again:"ÂÜçÊù•‰∏ÄÊ¨°", gameover:"Ê∏∏ÊàèÁªìÊùü", scoreLabel:"ÂæóÂàÜÔºö"},
    ja:{title:"SHEEP RUN", start:"„Çπ„Çø„Éº„Éà", again:"„ÇÇ„ÅÜ‰∏ÄÂõû", gameover:"„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº", scoreLabel:"„Çπ„Ç≥„Ç¢: "}
  };

  const PREP_TEXTS = {
    ru:{ready:"–ì–û–¢–û–í–´?", collect:"–°–û–ë–ò–†–ê–ô", avoid:"–ò–ó–ë–ï–ì–ê–ô", hint:"–ü–†–ò–ì–û–¢–û–í–¨–°–Ø!"},
    en:{ready:"READY?", collect:"COLLECT", avoid:"AVOID", hint:"GET READY!"},
    fr:{ready:"PR√äT ?", collect:"RAMASSE", avoid:"√âVITE", hint:"PR√âPARE-TOI !"},
    de:{ready:"BEREIT?", collect:"SAMMELN", avoid:"AUSWEICHEN", hint:"BEREIT MACHEN!"},
    es:{ready:"¬øLISTO?", collect:"COGE", avoid:"EVITA", hint:"¬°PREP√ÅRATE!"},
    it:{ready:"PRONTO?", collect:"RACCOGLI", avoid:"EVITA", hint:"PREPARATI!"},
    zh:{ready:"ÂáÜÂ§áÂ•Ω‰∫ÜÂêóÔºü", collect:"Êî∂ÈõÜ", avoid:"Ë∫≤ÈÅø", hint:"ÂáÜÂ§áÔºÅ"},
    ja:{ready:"Ê∫ñÂÇôOKÔºü", collect:"ÈõÜ„ÇÅ„Çà„ÅÜ", avoid:"„Çà„Åë„Çà„ÅÜ", hint:"Ê∫ñÂÇô„Åó„Å¶ÔºÅ"}
  };

  let CFG = {
    lang: 'en',
    mode: 'choice',         // choice | input
    math: false,
    transparentBg: false,
    randomQuestions: true,
    ui: {
      title: 'SHEEP RUN',
      start: 'PLAY',
      again: 'AGAIN',
      gameover: 'GAME OVER',
      scoreLabel: 'Score: '
    },
    gameplay: { winQuestions: 10 },
    assets: {
      hero: 'üêë',
      mirrorHero: false,
      obstacles: { ground:['üå≤'], good:['üåü'], bad:['ü¶Ö'] }
    },
    sounds: { mus:'https://raw.githubusercontent.com/kgbgamelab/audioplayer/main/Baa%20Dash.mp3', ding:'https://assets.mixkit.co/active_storage/sfx/2000/2000-preview.mp3', buzz:'https://assets.mixkit.co/active_storage/sfx/257/257-preview.mp3', coin:'https://assets.mixkit.co/active_storage/sfx/2019/2019-preview.mp3', crash:'https://assets.mixkit.co/active_storage/sfx/2042/2042-preview.mp3', win:'https://assets.mixkit.co/active_storage/sfx/2018/2018-preview.mp3' },
    tasks: []
  };

  function mergeCfg(base, inc){
    const out = Object.assign({}, base, inc || {});
    out.ui = Object.assign({}, base.ui || {}, inc?.ui || {});
    out.gameplay = Object.assign({}, base.gameplay || {}, inc?.gameplay || {});
    out.assets = Object.assign({}, base.assets || {}, inc?.assets || {});
    out.assets.obstacles = Object.assign({}, (base.assets||{}).obstacles || {}, (inc?.assets||{}).obstacles || {});
    out.sounds = Object.assign({}, base.sounds || {}, inc?.sounds || {});
    // arrays overwrite
    if(Array.isArray(inc?.tasks)) out.tasks = inc.tasks.slice();
    return out;
  }

  function normalizeCfg(raw){
    if(!raw) return {};
    let cfg = raw;

    // If editor packed everything into embeddedGameConfig
    if(cfg.embeddedGameConfig){
      cfg = Object.assign({}, cfg.embeddedGameConfig, cfg);
      delete cfg.embeddedGameConfig;
    }

    // Audio key alias
    if(cfg.audio && !cfg.sounds) cfg.sounds = cfg.audio;

    // Questions alias
    if(Array.isArray(cfg.questions) && !Array.isArray(cfg.tasks)){
      cfg.tasks = cfg.questions.map(q=>{
        // legacy {s,c,w}
        if(q && (q.s !== undefined || q.c !== undefined)){
          const correct = String(q.c ?? '').split('|').map(s=>s.trim()).filter(Boolean);
          const wrong = String(q.w ?? '').split('|').map(s=>s.trim()).filter(Boolean);
          return { question: String(q.s ?? '').trim(), correct, wrong };
        }
        // {question, correct, wrong}
        const question = String(q.question ?? '').trim();
        const corrRaw = q.correct ?? '';
        const wrRaw = q.wrong ?? '';
        const correct = Array.isArray(corrRaw) ? corrRaw : String(corrRaw).split('|');
        const wrong = Array.isArray(wrRaw) ? wrRaw : String(wrRaw).split('|');
        return {
          question,
          correct: correct.map(s=>String(s).trim()).filter(Boolean),
          wrong: wrong.map(s=>String(s).trim()).filter(Boolean)
        };
      });
      delete cfg.questions;
    }

    // If tasks exist but are in legacy shape {s,c,w}
    if(Array.isArray(cfg.tasks)){
      cfg.tasks = cfg.tasks.map(t=>{
        if(t && (t.s !== undefined || t.c !== undefined)){
          const correct = String(t.c ?? '').split('|').map(s=>s.trim()).filter(Boolean);
          const wrong = String(t.w ?? '').split('|').map(s=>s.trim()).filter(Boolean);
          return { question: String(t.s ?? '').trim(), correct, wrong };
        }
        const correct = Array.isArray(t.correct) ? t.correct : String(t.correct ?? '').split('|');
        const wrong = Array.isArray(t.wrong) ? t.wrong : String(t.wrong ?? '').split('|');
        return {
          question: String(t.question ?? '').trim(),
          correct: correct.map(s=>String(s).trim()).filter(Boolean),
          wrong: wrong.map(s=>String(s).trim()).filter(Boolean)
        };
      });
    }

    return cfg;
  }


  // Preview: receive config live from the editor (works cross-origin)
  window.addEventListener('message', (e)=>{
    const data = e?.data;
    if(!data || data.type !== 'SHEEP_CFG') return;
    try{
      CFG = mergeCfg(CFG, normalizeCfg(data.cfg));
      applyCfgToUI();
      if(typeof Game !== 'undefined' && Game.resetToStart) Game.resetToStart();
    }catch(err){}
  });


  async function loadConfig(){
    if(localMode || previewMode){
      try{
        const raw = localStorage.getItem('__sheep_cfg__'); // optional (same-origin preview)
        if(raw) CFG = mergeCfg(CFG, normalizeCfg(JSON.parse(raw)));
      }catch(e){}
      // if previewMode and nothing in localStorage, we will wait for postMessage
      return;
    }
    if(!cfgId) return;
    try{
      const res = await fetch(`${JSON_BASE}${encodeURIComponent(cfgId)}.json?v=${Date.now()}`, { cache:'no-store' });
      const cfg = normalizeCfg(await res.json());
      CFG = mergeCfg(CFG, cfg || {});
      try{ const n=document.getElementById('cfgNote'); if(n) n.textContent=''; }catch(_e){}
    }catch(e){
      try{ const n=document.getElementById('cfgNote'); if(n){ n.textContent = (cfgId ? ('‚ö†Ô∏è –ù–µ –Ω–∞–π–¥–µ–Ω –Ω–∞–±–æ—Ä –Ω–∞—Å—Ç—Ä–æ–µ–∫: ' + cfgId) : ''); } }catch(_e){}
    }
  }

  function ensureMathJax(){
    if(!CFG.math) return;
    if(document.getElementById('MathJax-script')) return;
    const mj = document.createElement('script');
    mj.id = 'MathJax-script';
    mj.async = true;
    mj.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
    document.head.appendChild(mj);
  }
  function typesetMaybe(el){
    if(!CFG.math) return;
    const tryTypeset = ()=>{
      if(window.MathJax && window.MathJax.typesetPromise){
        window.MathJax.typesetPromise([el]).catch(()=>{});
      }else{
        setTimeout(tryTypeset, 120);
      }
    };
    tryTypeset();
  }

  function applyCfgToUI(){
    const L = UI_DEFAULTS[CFG.lang] || UI_DEFAULTS.en;
    // transparency
    const app = document.getElementById('game-app');
    if(CFG.transparentBg){
      document.documentElement.classList.add('transparent');
      document.body.classList.add('transparent');
      app.classList.add('transparent');
    }

    // hero mirror scale
    document.documentElement.style.setProperty('--hero-scale', (CFG.assets?.mirrorHero ? -1 : 1));

    // question font size (vmin)
    if(CFG.ui && CFG.ui.fontSize){
      const fs = parseFloat(CFG.ui.fontSize);
      if(Number.isFinite(fs) && fs>0) document.documentElement.style.setProperty('--q-font', fs + 'vmin');
    }else{
      document.documentElement.style.setProperty('--q-font', '8vmin');
    }

    // title + heroes
    document.getElementById('uiTitle').textContent = (CFG.ui?.title || L.title || 'SHEEP RUN');
    renderContent(document.getElementById('startHero'), (CFG.assets?.hero || 'üêë'));
    renderContent(document.getElementById('hero'), (CFG.assets?.hero || 'üêë'));

    // buttons text
    document.getElementById('btnStart').textContent = (CFG.ui?.start || L.start || 'START');
    document.getElementById('btnAgain').textContent = (CFG.ui?.again || L.again || 'AGAIN');

    // apply text size (vmin)
    const uiFont = parseFloat(CFG.ui?.fontSize || '');
    if(Number.isFinite(uiFont) && uiFont > 0){
      document.documentElement.style.setProperty('--qSize',  uiFont+'vmin');
      document.documentElement.style.setProperty('--btnSize',uiFont+'vmin');
    }else{
      const scale = parseFloat(CFG.ui?.fontScale || '1');
      if(Number.isFinite(scale) && scale>0){
        document.documentElement.style.setProperty('--qSize',  (8*scale)+'vmin');
        document.documentElement.style.setProperty('--btnSize',(8*scale)+'vmin');
      }
    }

    // mode panels
    const mode = CFG.mode || 'choice';
    document.getElementById('choicePanel').style.display  = (mode === 'choice')  ? 'flex' : 'none';
        document.getElementById('inputPanel').style.display   = (mode === 'input')   ? 'flex' : 'none';

    // sounds urls
    const setSrc = (el, url)=>{ el.src = url || ''; try{ el.load(); }catch(e){} };
    setSrc(document.getElementById('mus-bg'),      (CFG.sounds?.mus || 'https://raw.githubusercontent.com/kgbgamelab/audioplayer/main/Baa%20Dash.mp3'));
    setSrc(document.getElementById('sfx-ding'),    CFG.sounds?.ding);
    setSrc(document.getElementById('sfx-buzz'),    CFG.sounds?.buzz);
    setSrc(document.getElementById('sfx-coin'),    CFG.sounds?.coin);
    setSrc(document.getElementById('sfx-crash'),   CFG.sounds?.crash);
    setSrc(document.getElementById('sfx-win'),     CFG.sounds?.win);

    
    // prep/instruction texts
    const P = PREP_TEXTS[CFG.lang] || PREP_TEXTS.en;
    const st = (id, val)=>{ const el=document.getElementById(id); if(el) el.textContent = val; };
    st('prepTitle',  P.ready);
    st('prepCollect',P.collect);
    st('prepAvoid',  P.avoid);
    st('prepHint',   P.hint);
ensureMathJax();
  }

  // -------- AUDIO (music + safe fallback sfx) --------
  const AudioFallback = {
    ctx:null,
    ensure(){
      if(this.ctx) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      if(!AC) return;
      this.ctx = new AC();
    },
    beep(freq=440, ms=120, type='sine', gain=0.08){
      this.ensure();
      if(!this.ctx) return;
      const o = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(this.ctx.destination);
      o.start();
      o.stop(this.ctx.currentTime + ms/1000);
    },
    noise(ms=120, gain=0.06){
      this.ensure();
      if(!this.ctx) return;
      const bufferSize = Math.floor(this.ctx.sampleRate * (ms/1000));
      const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for(let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1) * 0.6;
      const src = this.ctx.createBufferSource();
      src.buffer = buffer;
      const g = this.ctx.createGain();
      g.gain.value = gain;
      src.connect(g); g.connect(this.ctx.destination);
      src.start();
    },
    sfx(kind){
      // simple "base sounds" if URLs are empty
      switch(kind){
        case 'ding':  this.beep(880, 110, 'triangle', 0.08); break;
        case 'coin':  this.beep(1040, 90, 'square', 0.06); this.beep(1560, 70, 'square', 0.04); break;
        case 'buzz':  this.beep(140, 180, 'sawtooth', 0.07); break;
        case 'crash': this.noise(160, 0.08); this.beep(90, 120, 'sine', 0.06); break;
        case 'win':   this.beep(660, 130, 'triangle', 0.07); setTimeout(()=>this.beep(880, 170, 'triangle', 0.07), 140); break;
      }
    }
  };

  const AudioSys = {
    mus: null,
    vMus: 0.5,
    vSfx: 1,
    unlocked: false,
    init(){
      this.mus = document.getElementById('mus-bg');
      document.getElementById('slider-mus').addEventListener('input', (e)=>{ this.unlock(); this.setVol('mus', e.target.value); this.playMusic(); });
      document.getElementById('slider-sfx').addEventListener('input', (e)=>this.setVol('sfx', e.target.value));

      document.getElementById('musIcon').addEventListener('click', ()=>{
        this.unlock();
        if(this.mus && !this.mus.paused) this.mus.pause();
        else this.playMusic();
      });

      document.getElementById('sfxIcon').addEventListener('click', ()=>{
        this.unlock();
        this.play('ding');
      });
    },
    unlock(){
      if(this.unlocked) return;
      this.unlocked = true;
      try{ AudioFallback.ensure(); if(AudioFallback.ctx && AudioFallback.ctx.state === 'suspended') AudioFallback.ctx.resume().catch(()=>{}); }catch(e){}
      this.playMusic(true);
    },
    setVol(t,v){
      v = parseFloat(v);
      if(!Number.isFinite(v)) return;
      if(t==='mus'){
        this.vMus = v;
        if(this.mus) this.mus.volume = v;
      }else{
        this.vSfx = v;
      }
    },
    play(id){
      const el = document.getElementById('sfx-'+id);
      if(el && el.src){
        el.volume = this.vSfx;
        el.currentTime = 0;
        el.play().catch(()=>{});
      }else{
        AudioFallback.sfx(id);
      }
    },
    playMusic(forceUnlock=false){
      if(!this.mus || !this.mus.src) return;
      this.mus.volume = forceUnlock ? 0.0001 : this.vMus;
      this.mus.play().then(()=>{
        if(forceUnlock) setTimeout(()=>{ this.mus.volume = this.vMus; }, 0);
      }).catch(()=>{});
    }
  };

  // -------- GAME --------
  const Game = {
    isPlaying:false,
    score:0,
    lives:5,
    combo:1.0,
    obstaclesPassed:0,
    spawnInterval:5000,
    isInvincible:false,

    qOrder: [],
    qIndex: 0,
    currentTask: null,

    elHero:null,
    elObjs:null,
    mainInterval:null,
    spawnTimer:null,

    setDifficulty(mode){
      document.querySelectorAll('.diff-btn').forEach(b=>b.classList.remove('active'));
      const el = document.getElementById('diff-'+mode);
      if(el) el.classList.add('active');

      let speed, spawn;
      switch(mode){
        case 'easy':   speed='4.5s'; spawn=6000; break;
        case 'medium': speed='3.5s'; spawn=5000; break;
        case 'hard':   speed='2.8s'; spawn=4000; break;
        default:       speed='3.5s'; spawn=5000;
      }
      document.documentElement.style.setProperty('--move-speed', speed);
      this.spawnInterval = spawn;
    },

    setupTutorialIcons(){
      const gl = document.getElementById('tut-good-list');
      const bl = document.getElementById('tut-bad-list');
      gl.innerHTML=''; bl.innerHTML='';

      (CFG.assets?.obstacles?.good || []).forEach(a=>{
        const d=document.createElement('div');
        d.className='tut-icon-wrap';
        renderContent(d, a);
        gl.appendChild(d);
      });

      const allBad = [...new Set([...(CFG.assets?.obstacles?.bad||[]), ...(CFG.assets?.obstacles?.ground||[])])];
      allBad.forEach(a=>{
        const d=document.createElement('div');
        d.className='tut-icon-wrap';
        renderContent(d, a);
        bl.appendChild(d);
      });
    },

    showPrep(){
      AudioSys.unlock();
      document.getElementById('start-screen').style.display='none';
      document.getElementById('prep-screen').style.display='flex';
      this.setupTutorialIcons();

      let count=5;
      const cd=document.getElementById('countdown');
      cd.textContent = count;

      const timer=setInterval(()=>{
        count--;
        cd.textContent = count;
        if(count<=0){
          clearInterval(timer);
          this.init();
        }
      },1000);
    },

    init(){
      this.elHero = document.getElementById('hero');
      this.elObjs = document.getElementById('objects-layer');

      this.isPlaying=true;
      this.score=0; this.lives=5; this.combo=1.0; this.obstaclesPassed=0;
      this.isInvincible=false;

      document.getElementById('prep-screen').style.display='none';
      document.getElementById('question-card').style.display='block';
      this.elObjs.innerHTML='';

      // prepare question order
      this.qOrder = (CFG.tasks || []).map((t,idx)=>idx);
      if(CFG.randomQuestions) this.qOrder = shuffle(this.qOrder);
      this.qIndex = 0;
      this.obstaclesPassed = 0;
      this.answerAccepted = false;

      // panels
      const mode = CFG.mode || 'choice';
      document.getElementById('choicePanel').style.display  = (mode==='choice') ? 'flex' : 'none';
      document.getElementById('choicePanel').style.display = (mode==='choice') ? 'grid' : 'none';
      document.getElementById('inputPanel').style.display   = (mode==='input')  ? 'flex' : 'none';

      // bind controls
      document.getElementById('btn-left').onclick  = ()=>this.handleChoiceBtn(document.getElementById('btn-left'));
      document.getElementById('btn-right').onclick = ()=>this.handleChoiceBtn(document.getElementById('btn-right'));
      ['a','b','c','d'].forEach(k=>{ const el=document.getElementById('btn-'+k); if(el) el.onclick=()=>this.handleChoiceBtn(el); });
      document.getElementById('btnOk').onclick = ()=>this.handleInputOk();
      document.getElementById('answerInput').onkeydown = (e)=>{ if(e.key === 'Enter') this.handleInputOk(); };

      this.elHero.className = 'hero-char' + ((CFG.assets && CFG.assets.heroBobbing===false) ? '' : ' bobbing');
      this.updateUI();
      this.nextQuestion();

      // apply current difficulty (default medium)
      const activeDiff = (document.querySelector('.diff-btn.active')?.id || 'diff-medium').replace('diff-','');
      this.setDifficulty(activeDiff);
      // INPUT mode needs more time to type
      if((CFG.mode||'choice') === 'input') this.spawnInterval = Math.round(this.spawnInterval * 3);

      if(this.mainInterval) clearInterval(this.mainInterval);
      this.mainInterval = setInterval(()=>this.mainLoop(), 50);

      if(this.spawnTimer) clearInterval(this.spawnTimer);
      const firstDelay = ((CFG.mode||'choice')==='input') ? 4500 : 2500;
      setTimeout(()=>{
        if(!this.isPlaying) return;
        this.spawnObject('ground');
        setTimeout(()=>{ if(this.isPlaying) this.spawnObject('air'); }, this.spawnInterval/2);
        this.spawnTimer = setInterval(()=>{
          if(!this.isPlaying) return;
          this.spawnObject('ground');
          setTimeout(()=>{ if(this.isPlaying) this.spawnObject('air'); }, this.spawnInterval/2);
        }, this.spawnInterval);
      }, firstDelay);

      AudioSys.playMusic();
    },

    spawnObject(mode){
      const div=document.createElement('div');
      div.className='game-obj obj-move';
      let type, content, posClass;

      if(mode==='ground'){
        type='bad';
        content=this.randomItem(CFG.assets?.obstacles?.ground || ['üå≤']);
        posClass='pos-ground';
        div.dataset.isObstacle="true";
      }else{
        type = Math.random()>0.5 ? 'good' : 'bad';
        content = (type==='good')
          ? this.randomItem(CFG.assets?.obstacles?.good || ['üåü'])
          : this.randomItem(CFG.assets?.obstacles?.bad || ['ü¶Ö']);
        posClass='pos-air';
      }

      renderContent(div, content);
      div.dataset.type = type;
      div.classList.add(posClass);
      this.elObjs.appendChild(div);

      setTimeout(()=>{ if(div.parentNode) div.remove(); }, 5000);
    },

    spawnFeedback(x,y,text,color){
      const span=document.createElement('div');
      span.className='floating-text';
      span.textContent=text;
      span.style.left=x+'px';
      span.style.top=y+'px';
      span.style.color=color;
      document.getElementById('sky-area').appendChild(span);
      setTimeout(()=>span.remove(), 800);
    },

    mainLoop(){
      if(!this.isPlaying) return;

      const hR=this.elHero.getBoundingClientRect();
      const hX=hR.left+hR.width*0.4;
      const hW=hR.width*0.2;
      const hT=hR.top+hR.height*0.3;
      const hB=hR.bottom-hR.height*0.1;

      document.querySelectorAll('.game-obj:not(.obj-caught)').forEach(obj=>{
        const oR=obj.getBoundingClientRect();
        const oX=oR.left+oR.width*0.3;
        const oW=oR.width*0.4;
        const oT=oR.top+oR.height*0.3;
        const oB=oR.bottom-oR.height*0.1;

        // obstacle passed (ground) -> next question
        if(obj.dataset.isObstacle === "true" && !obj.dataset.passed && oR.right < hX){
          // obstacle went past hero line
          this.onObstaclePassed(obj);
        }


        if(hX < oX + oW && hX + hW > oX && hT < oB && hB > oT){
          const centerX=oR.left+oR.width/2;
          const centerY=oR.top;

          if(obj.dataset.type==='good'){
            const pts=Math.floor(150*this.combo);
            this.score += pts;
            this.spawnFeedback(centerX, centerY, "+"+pts, "#4CAF50");
            obj.classList.add('obj-caught');
            AudioSys.play('coin');
            setTimeout(()=>obj.remove(), 400);
          }else if(!this.isInvincible){
            this.spawnFeedback(centerX, centerY, "-1 ‚ù§Ô∏è", "#F44336");
            obj.remove();
            this.hurt();
          }
          this.updateUI();
        }
      });
    },

    onObstaclePassed(obj){
      // In INPUT mode: the player must have answered correctly before we count the jump.
      const mode = (CFG.mode||'choice');
      if(mode === 'input'){
        if(!this.answerAccepted) return; // don't advance if no correct answer yet
      }
      if(obj) obj.dataset.passed = "true";

      this.obstaclesPassed = (this.obstaclesPassed || 0) + 1;

      // INPUT mode: keep the typed answer until the jump is counted, then clear for next question.
      if(mode === 'input'){
        const inp=document.getElementById('answerInput');
        inp.disabled = false;
        document.getElementById('btnOk').disabled = false;
        inp.value = '';
        inp.focus();
      }

      // reset state for next obstacle/question
      this.answerAccepted = false;

      this.qIndex++;
      this.nextQuestion();

      const need = Math.max(1, CFG.gameplay?.winQuestions || 10);
      if(this.obstaclesPassed >= need) this.gameOver(true);
      this.updateUI();
    },

    hurt(){
      this.lives--;
      this.combo=1.0;
      this.isInvincible=true;
      AudioSys.play('crash');

      this.elHero.classList.add('blink-anim');
      this.updateUI();

      if(this.lives<=0) this.gameOver(false);
      else setTimeout(()=>{
        this.isInvincible=false;
        this.elHero.classList.remove('blink-anim');
      }, 1500);
    },

    // ----- QUESTIONS FLOW -----
    nextQuestion(){
      const qt = document.getElementById('question-text');

      if(!CFG.tasks || !CFG.tasks.length){
        renderContent(qt, '...');
        this.currentTask = null;
        return;
      }

      if(this.qIndex >= this.qOrder.length){
        this.gameOver(true);
        return;
      }

      const idx = this.qOrder[this.qIndex];
      const task = CFG.tasks[idx] || { question:'...', correct:['OK'], wrong:['NO'] };
      this.currentTask = task;

      renderContent(qt, task.question || '...');
      typesetMaybe(qt);

      const mode = (CFG.mode||'choice');

      if(mode === 'choice'){
        const correct = (task.correct && task.correct[0]) ? task.correct[0] : 'OK';
        const wrong   = (task.wrong && task.wrong[0]) ? task.wrong[0] : 'NO';

        const bL=document.getElementById('btn-left');
        const bR=document.getElementById('btn-right');

        // reset lock
        bL.disabled = false; bR.disabled=false;

        if(Math.random()>0.5){
          renderContent(bL, correct); bL.dataset.correct="true";
          renderContent(bR, wrong); bR.dataset.correct="false";
        }else{
          renderContent(bL, wrong); bL.dataset.correct="false";
          renderContent(bR, correct); bR.dataset.correct="true";
        }
      }else if(mode === 'choice'){
        const correct = (task.correct && task.correct[0]) ? task.correct[0] : 'OK';
        const wrongPool = (task.wrong && task.wrong.length) ? task.wrong.slice() : ['NO','NOPE','WRONG'];
        while(wrongPool.length < 3) wrongPool.push(wrongPool[wrongPool.length-1] || 'NO');

        const wrong = wrongPool[0] || 'NO';
        // Randomize left/right
        const leftIsCorrect = Math.random() > 0.5;
        const bA = document.getElementById('btn-a');
        const bB = document.getElementById('btn-b');
        if(bA && bB){
          bA.disabled = false; bB.disabled = false;
          renderContent(bA, leftIsCorrect ? correct : wrong);
          renderContent(bB, leftIsCorrect ? wrong : correct);
          bA.dataset.correct = leftIsCorrect ? "true" : "false";
          bB.dataset.correct = leftIsCorrect ? "false" : "true";
        }
      }else{
        const inp = document.getElementById('answerInput');
        // keep user's text unless we are switching task; we do clear on obstacle passed
        if(!this.answerAccepted) inp.value = '';
        inp.disabled = false;
        document.getElementById('btnOk').disabled = false;
        inp.focus();
      }

      this.updateUI();
    },

    handleChoiceBtn(btn){
      if(!this.isPlaying) return;
      if(!btn) return;

      if(btn.dataset.correct === "true"){
        this.onAnswerCorrect();
      }else{
        AudioSys.play('buzz');
        this.hurt();
      }
      this.updateUI();
    },

    handleInputOk(){
      if(!this.isPlaying) return;
      if(!this.currentTask) return;

      const inp = document.getElementById('answerInput');
      const val = (inp.value || '').trim().toLowerCase();

      const correctList = (this.currentTask.correct || []).map(s=>String(s).trim().toLowerCase()).filter(Boolean);
      const ok = correctList.includes(val);

      if(ok){
        this.onAnswerCorrect();
      }else{
        AudioSys.play('buzz');
        this.hurt();
      }
      this.updateUI();
    },

    onAnswerCorrect(){
      // Allow repeated jumps. Score/combo only once per obstacle.
      if(!this.elHero.classList.contains('jump-anim')){
        this.elHero.classList.add('jump-anim');
        setTimeout(()=>this.elHero.classList.remove('jump-anim'), 1000);
      }

      if(!this.answerAccepted){
        AudioSys.play('ding');
        this.score += Math.floor(200*this.combo);
        this.combo = Math.min(this.combo + 0.5, 5.0);
        this.answerAccepted = true;
      }else{
        // already correct for this obstacle: just jump again (no extra points)
        AudioSys.play('ding');
      }

      // INPUT mode: keep text, do NOT disable controls
      if((CFG.mode||'choice') === 'input'){
        document.getElementById('answerInput').disabled = false;
        document.getElementById('btnOk').disabled = false;
      }
    },

    updateUI(){
      document.getElementById('lives-display').textContent = '‚ù§Ô∏è'.repeat(Math.max(0, this.lives));
      document.getElementById('score-display').textContent = String(this.score);
      document.getElementById('combo-display').textContent = 'x' + this.combo.toFixed(1);

      const total = Math.max((CFG.gameplay?.winQuestions || 10), (CFG.tasks || []).length || 10);
      const pct = Math.min((this.obstaclesPassed / total) * 100, 100);
      document.getElementById('progress-fill').style.width = pct + '%';
    },

    gameOver(isWin){
      this.isPlaying=false;
      clearInterval(this.spawnTimer);
      clearInterval(this.mainInterval);

      document.getElementById('end-emoji').textContent = isWin ? 'üèÜ' : 'üíÄ';
      const L = UI_DEFAULTS[CFG.lang] || UI_DEFAULTS.en;
      document.getElementById('end-title').textContent = isWin ? 'YOU WIN!' : (CFG.ui?.gameover || L.gameover || 'TRY AGAIN');
      document.getElementById('end-score-text').textContent = (CFG.ui?.scoreLabel || (L.scoreLabel||'Score: ')) + this.score;

      document.getElementById('end-screen').style.display='flex';
      if(isWin) AudioSys.play('win');
    },

    resetToStart(){
      // stop timers
      this.isPlaying = false;
      try{ clearInterval(this.spawnTimer); }catch(e){}
      try{ clearInterval(this.mainInterval); }catch(e){}
      // clear objects + UI
      this.elObjs.innerHTML = '';
      document.getElementById('end-screen').style.display='none';
      document.getElementById('prep-screen').style.display='none';
      document.getElementById('question-card').style.display='none';
      document.getElementById('start-screen').style.display='flex';
      document.getElementById('answerInput').value='';
      // reflect new hero + tasks immediately
      renderContent(document.getElementById('startHero'), (CFG.assets?.hero || 'üêë'));
      renderContent(this.elHero, (CFG.assets?.hero || 'üêë'));
      // start smoke already styled to fly left (no config needed)
    },

    randomItem(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
  };

  // -------- BOOT --------
  (async function boot(){
    await loadConfig();
    applyCfgToUI();

    AudioSys.init();
    AudioSys.setVol('mus', document.getElementById('slider-mus').value);
    AudioSys.setVol('sfx', document.getElementById('slider-sfx').value);

    document.getElementById('diff-easy').onclick   = ()=>Game.setDifficulty('easy');
    document.getElementById('diff-medium').onclick = ()=>Game.setDifficulty('medium');
    document.getElementById('diff-hard').onclick   = ()=>Game.setDifficulty('hard');
    Game.setDifficulty('medium');

    document.getElementById('btnStart').onclick = ()=>Game.showPrep();
    document.getElementById('btnAgain').onclick = ()=>location.reload();
  })();
</script>
</body>
</html>
